`timescale 1ns / 1ps

module InstructionMemory (
    input clk,
    input reset,
    input [31:0] address,

    output reg [31:0] readData
);

  reg [31:0] memory[0:63];

  always @(*) begin
    if (reset) begin
      readData = memory[0];
    end else begin
      readData = memory[address>>2];
    end
  end

  initial begin
    readData   = 32'b100011_00011_00001_0000000000000000;
    memory[0]  = 32'b100011_00011_00001_0000000000000000;  //   lw $1, 0($3)
    memory[1]  = 32'b100011_00011_00010_0000000000000100;  //   lw $2, 4($3)
    memory[2]  = 32'b000000_00000_00010_00100_00001_000010;  // srl $4, $2, 1
    memory[3]  = 32'b000000_00000_00100_00101_00001_000000;  // sll $5, $4, 1
    memory[4]  = 32'b000100_00010_00101_0000000000000001;  //   beq $5, $2, 1
    memory[5]  = 32'b000000_01000_00001_01000_00000_100000;  // add $8, $8, $1
    memory[6]  = 32'b000000_00000_00010_00010_00001_000010;  // srl $2, $2, 1
    memory[7]  = 32'b000000_00000_00001_00001_00001_000000;  // sll $1, $1, 1
    memory[8]  = 32'b000100_00011_00010_0000000000000001;  //   beq $2, $3, 1
    memory[9]  = 32'b000010_00000000000000000000000010;  //     j 2
    memory[10] = 32'b101011_00011_01000_0000000000001000;  //   sw $8, 8($0)
    memory[11] = 32'b000000_00000_00000_01000_00000_100000;  // add $8, $0, $0
    memory[12] = 32'b000010_00000000000000000000000000;  //     j 0
  end

endmodule
